# ماژول‌های اصلی

`undefined`

LlamaIndex.TS چندین ماژول اصلی را ارائه می‌دهد که به ماژول‌های سطح بالا برای شروع سریع و ماژول‌های سطح پایین برای سفارشی‌سازی اجزای کلیدی به میزانی که نیاز دارید تقسیم می‌شوند.

## ماژول‌های سطح بالا

- [**سند**](./high_level/documents_and_nodes.md): یک سند نماینده یک فایل متنی، فایل PDF یا قطعه داده پیوسته دیگر است.

- [**نود**](./high_level/documents_and_nodes.md): بلوک ساختاری اصلی داده. بیشترین استفاده از این ماژول‌ها برای تقسیم سند به قطعات قابل مدیریت است که به اندازه کافی کوچک هستند تا به یک مدل تعبیه شده و LLM تغذیه شوند.

- [**خواننده/بارگذار**](./high_level/data_loader.md): خواننده یا بارگذار چیزی است که یک سند را در دنیای واقعی دریافت کرده و آن را به یک کلاس سند تبدیل می‌کند که سپس در شاخص و پرسمان‌های شما قابل استفاده است. در حال حاضر ما پشتیبانی می‌کنیم از فایل‌های متنی ساده و PDF با بسیاری از فرمت‌های دیگر.

- [**شاخص‌ها**](./high_level/data_index.md): شاخص‌ها نودها و تعبیه‌های آن‌ها را ذخیره می‌کنند.

- [**موتور پرسمان**](./high_level/query_engine.md): موتورهای پرسمان آنچه را که در آن قرار می‌دهید تولید می‌کنند و نتیجه را به شما باز می‌گردانند. موتورهای پرسمان به طور کلی یک پیش‌نویس از پیش ساخته را با گرفتن نودهای انتخاب شده از شاخص شما ترکیب می‌کنند تا متناظر با پرسمان شما، متناظر با پرسمان شما را به LLM بدهند.

- [**موتور چت**](./high_level/chat_engine.md): یک موتور چت به شما کمک می‌کند تا یک ربات چت بسازید که با شاخص‌های شما تعامل داشته باشد.

## ماژول سطح پایین

- [**LLM**](./low_level/llm.md): کلاس LLM یک رابط یکپارچه بر روی یک ارائه دهنده مدل زبان بزرگ مانند OpenAI GPT-4، Anthropic Claude یا Meta LLaMA است. شما می‌توانید آن را زیرکلاس کنید تا یک اتصال به مدل زبان بزرگ خود بنویسید.

- [**Embedding**](./low_level/embedding.md): یک embedding به عنوان یک بردار از اعداد اعشاری نمایش داده می‌شود. مدل embedding پیش‌فرض ما text-embedding-ada-002 از OpenAI است و هر embedding که تولید می‌کند، شامل ۱۵۳۶ عدد اعشاری است. یک مدل embedding محبوب دیگر BERT است که از ۷۶۸ عدد اعشاری برای نمایش هر نود استفاده می‌کند. ما تعدادی ابزار برای کار با embeddings ارائه می‌دهیم که شامل ۳ گزینه محاسبه شباهت و Maximum Marginal Relevance است.

- [**TextSplitter/NodeParser**](./low_level/node_parser.md): استراتژی‌های تقسیم متن بسیار مهم برای کارآیی کلی جستجوی embedding هستند. در حال حاضر، هرچند که ما یک مقدار پیش‌فرض داریم، اما هیچ راه‌حل یک اندازه برای همه وجود ندارد. بسته به سند منبع، شما ممکن است بخواهید از اندازه‌ها و استراتژی‌های تقسیم مختلف استفاده کنید. در حال حاضر، ما پشتیبانی از تقسیم بر اساس اندازه ثابت، تقسیم بر اساس اندازه ثابت با بخش‌های همپوشانی، تقسیم بر اساس جمله و تقسیم بر اساس پاراگراف را ارائه می‌دهیم. TextSplitter هنگام تقسیم سند‌ها به نودها از NodeParser استفاده می‌کند.

- [**Retriever**](./low_level/retriever.md): Retriever وظیفه انتخاب نودهایی را که باید از ایندکس بازیابی شوند، بر عهده دارد. در اینجا، شما ممکن است بخواهید تعداد بیشتر یا کمتری نود در هر پرس و جو بازیابی کنید، تابع شباهت خود را تغییر دهید یا برای هر مورد استفاده مجزا در برنامه خود یک بازیابی‌کننده جداگانه ایجاد کنید. به عنوان مثال، ممکن است بخواهید برای محتوای کد در مقابل محتوای متنی یک بازیابی‌کننده جداگانه داشته باشید.

- [**ResponseSynthesizer**](./low_level/response_synthesizer.md): ResponseSynthesizer مسئول دریافت یک رشته پرس و جو است و با استفاده از لیستی از نودها، یک پاسخ تولید می‌کند. این می‌تواند به شکل‌های مختلفی باشد، مانند تکرار کل متن و بهبود پاسخ، یا ساختن یک درخت از خلاصه‌ها و برگرداندن خلاصه ریشه.

- [**Storage**](./low_level/storage.md): در نهایت، شما می‌خواهید ایندکس‌ها، داده‌ها و بردارهای خود را ذخیره کنید به جای اجرای مدل‌های embedding هر بار. IndexStore، DocStore، VectorStore و KVStore انتزاعاتی هستند که به شما این امکان را می‌دهند. با هم ترکیب شده، آنها StorageContext را تشکیل می‌دهند. در حال حاضر، ما به شما اجازه می‌دهیم تا embedding های خود را در فایل‌ها در سیستم فایل (یا یک سیستم فایل مجازی در حافظه) ذخیره کنید، اما همچنین در حال اضافه کردن اتصالات به پایگاه‌های داده برداری فعال هستیم.
