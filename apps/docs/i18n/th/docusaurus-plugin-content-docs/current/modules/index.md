# โมดูลหลัก

`เอกสารนี้ได้รับการแปลโดยอัตโนมัติและอาจมีข้อผิดพลาด อย่าลังเลที่จะเปิด Pull Request เพื่อแนะนำการเปลี่ยนแปลง.`

LlamaIndex.TS มีโมดูลหลักหลายระดับ แยกเป็นโมดูลระดับสูงสำหรับเริ่มต้นใช้งานได้อย่างรวดเร็ว และโมดูลระดับต่ำสำหรับปรับแต่งส่วนประกอบหลักตามความต้องการของคุณ

## โมดูลระดับสูง

- [**เอกสาร**](./high_level/documents_and_nodes.md): เอกสารแทนไฟล์ข้อความ ไฟล์ PDF หรือข้อมูลต่อเนื่องอื่น ๆ

- [**โหนด**](./high_level/documents_and_nodes.md): ส่วนประกอบข้อมูลพื้นฐาน โดยทั่วไปแล้วเป็นส่วนของเอกสารที่แบ่งออกเป็นส่วนย่อยที่สามารถจัดการได้และเล็กพอที่จะสามารถนำเข้าโมเดลฝังตัวและ LLM

- [**อ่าน/โหลด**](./high_level/data_loader.md): อ่านหรือโหลดเป็นสิ่งที่รับเอกสารในโลกจริงและแปลงเป็นคลาสเอกสารที่สามารถใช้ในดัชนีและคิวรีของคุณได้ เราสนับสนุนไฟล์ข้อความธรรมดาและไฟล์ PDF และอีกมากมาย

- [**ดัชนี**](./high_level/data_index.md): ดัชนีเก็บโหนดและการฝังตัวของโหนดเหล่านั้น

- [**เครื่องมือค้นหา**](./high_level/query_engine.md): เครื่องมือค้นหาคือสิ่งที่สร้างคำค้นที่คุณใส่เข้าไปและให้ผลลัพธ์กลับมาให้คุณ เครื่องมือค้นหาทั่วไปจะรวมคำพูดที่สร้างไว้ล่วงหน้ากับโหนดที่เลือกจากดัชนีของคุณเพื่อให้ LLM มีบริบทที่จำเป็นในการตอบคำถามของคุณ

- [**เครื่องมือแชท**](./high_level/chat_engine.md): เครื่องมือแชทช่วยให้คุณสร้างแชทบอทที่จะปฏิสัมพันธ์กับดัชนีของคุณ

## โมดูลระดับต่ำ

- [**LLM**](./low_level/llm.md): คลาส LLM เป็นอินเตอร์เฟซที่รวมกันของผู้ให้บริการโมเดลภาษาขนาดใหญ่ เช่น OpenAI GPT-4, Anthropic Claude หรือ Meta LLaMA คุณสามารถสร้างคลาสย่อยขึ้นมาเพื่อเขียนตัวเชื่อมต่อกับโมเดลภาษาขนาดใหญ่ของคุณเอง

- [**Embedding**](./low_level/embedding.md): การฝังข้อมูลแสดงในรูปแบบเวกเตอร์ที่ประกอบด้วยตัวเลขทศนิยม โมเดลฝังข้อความ text-embedding-ada-002 ของ OpenAI เป็นโมเดลฝังข้อมูลเริ่มต้นของเราและแต่ละโมเดลฝังข้อมูลจะประกอบด้วยตัวเลขทศนิยม 1,536 ตัวเลขทศนิยม โมเดลฝังข้อมูลยอดนิยมอีกตัวอย่างคือ BERT ซึ่งใช้ตัวเลขทศนิยม 768 ตัวเลขทศนิยมในการแสดงแต่ละโหนด โดยเรามีเครื่องมือหลายรายการที่ใช้ในการทำงานกับการฝังข้อมูลรวมถึงตัวเลือกการคำนวณความคล้ายคลึง 3 ตัวเลือกและ Maximum Marginal Relevance

- [**TextSplitter/NodeParser**](./low_level/node_parser.md): กลยุทธ์ในการแบ่งข้อความเป็นส่วนย่อยๆ เป็นสิ่งสำคัญอย่างมากต่อประสิทธิภาพของการค้นหาข้อมูลที่ฝังอยู่ ในปัจจุบันเรามีค่าเริ่มต้นในการแบ่งข้อความ แต่ไม่มีวิธีที่เหมาะกับทุกกรณี ขึ้นอยู่กับเอกสารต้นฉบับคุณอาจต้องการใช้ขนาดและกลยุทธ์ในการแบ่งที่แตกต่างกัน ในปัจจุบันเราสนับสนุนการแบ่งตามขนาดคงที่ การแบ่งตามขนาดคงที่พร้อมกับส่วนที่ซ้อนทับ การแบ่งตามประโยค และการแบ่งตามย่อหน้า ตัวแบ่งข้อความถูกใช้โดย NodeParser เมื่อแบ่ง `Document` เป็น `Node`

- [**Retriever**](./low_level/retriever.md): Retriever เป็นส่วนที่เลือก Node ที่จะเรียกคืนจากดัชนี ที่นี่คุณอาจต้องการลองเรียกคืน Node มากหรือน้อยกว่านี้ การเปลี่ยนฟังก์ชันความคล้ายคลึงของคุณ หรือสร้าง Retriever เองสำหรับแต่ละกรณีการใช้งานในแอปพลิเคชันของคุณ เช่น คุณอาจต้องการ Retriever แยกสำหรับเนื้อหาของโค้ดกับเนื้อหาข้อความ

- [**ResponseSynthesizer**](./low_level/response_synthesizer.md): ResponseSynthesizer รับผิดชอบในการรับสตริงคำถาม และใช้รายการ `Node` เพื่อสร้างคำตอบ สามารถทำได้หลายรูปแบบ เช่น การวนซ้ำผ่านทั้งหมดของเนื้อหาและปรับปรุงคำตอบ หรือสร้างต้นไม้ของสรุปและส่งคืนสรุปรากฐาน

- [**Storage**](./low_level/storage.md): ในบางจุดคุณอาจต้องการเก็บดัชนีของคุณ ข้อมูลและเวกเตอร์เพื่อไม่ต้องรันโมเดลฝังข้อมูลทุกครั้ง IndexStore, DocStore, VectorStore และ KVStore เป็นการแยกแยะที่ช่วยให้คุณทำได้ รวมกันเป็น StorageContext ในปัจจุบันเราอนุญาตให้คุณเก็บฝังข้อมูลของคุณในไฟล์บนระบบไฟล์ (หรือระบบไฟล์เสมือนในหน่วยความจำ) แต่เรากำลังเพิ่มการรวมระบบฐานข้อมูลเวกเตอร์อย่างต่อเนื่อง

"
